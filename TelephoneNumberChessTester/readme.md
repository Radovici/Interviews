# Dynamic Chess Engine for Financial Asset Management Interview

## Overview
This repository contains a dynamic chess engine developed as part of a take-home programming interview for a position at a financial alternative asset manager. The engine is designed with extensibility and flexibility in mind, using a JSON configuration to dynamically define chess pieces, board layouts, and moves. This approach allows for adjustments to the game setup at runtime without the need to alter the code or restart the application.

## Original Instructions
The original PDF with detailed instructions and guidelines for this project can be found [here](./Chess.pdf).

## Features
- **Dynamic Configuration:** Chess board, pieces, and game moves can be configured dynamically using a JSON file. This makes the system adaptable and extensible to other types of games and scenarios.
- **Extensible Design:** The design supports various game types, board sizes, and piece types, enabling easy expansion and customization.
- **Test Console Application:** Includes a console application for testing the functionality of the chess engine.

## Results
The engine calculates the number of possible telephone numbers per chess piece based on their movements across the board:
- Pawn: 0
- Rook: 5034
- Knight: 952
- Bishop: 864
- Queen: 135495
- King: 124908
- Eldar (Custom Piece): 120

## JSON Configuration
The JSON configuration file plays a critical role in defining the dynamics of the chess engine. It allows for the flexible specification of board layouts, piece movements, and game rules without altering the underlying codebase. Here's a breakdown of the key components:

- **Board:** Defines the layout of the chess board as a grid, where each array element represents a row.
- **Exclusions:** Sets conditions for excluding certain numbers from being valid moves, such as numbers containing specific characters or starting with certain digits.
- **Terminators:** Defines conditions under which a series of moves should terminate.
- **Pieces:** Specifies the types of pieces available and their respective movement patterns.

### Example Configuration:
```json
{
  "board": [
    [ "1", "2", "3" ],
    [ "4", "5", "6" ],
    [ "7", "8", "9" ],
    [ "*", "0", "#" ]
  ],
  "exclusions": [
    "p => p.Contains('*') || p.Contains('#')",
    "p => p.StartsWith('0') || p.StartsWith('1')"
  ],
  "terminators": [ "p => p.Length == 7" ],
  "pieces": [
    {
      "name": "Pawn",
      "moves": [ "u" ]
    },
    {
      "name": "Rook",
      "moves": [ "U", "D", "R", "L" ]
    },
    {
      "name": "Knight",
      "moves": [ "uur", "uul", "llu", "lld", "rru", "rrd", "ddl", "ddr" ]
    },
    {
      "name": "Bishop",
      "moves": [ "1", "2", "3", "4" ]
    },
    {
      "name": "Queen",
      "moves": [ "U", "D", "R", "L", "1", "2", "3", "4" ]
    },
    {
      "name": "King",
      "moves": [ "*" ]
    },
    {
      "name": "Eldar",
      "moves": [ "ll", "rr" ]
    }
  ]
}
```

## Movement Mechanics

The chess engine uses a combination of lowercase and uppercase letters, along with a wildcard character, to define the movement patterns of pieces. Each piece has a set of valid moves represented in the JSON configuration.

### Move Definitions
- **Lowercase Letters (`u`, `d`, `r`, `l`):** These letters represent single-step movements in specific directions:
  - `u`: Up (North)
  - `d`: Down (South)
  - `r`: Right (East)
  - `l`: Left (West)

- **Numbers (`1`, `2`, `3`, `4`):** Represent diagonals:
  - `1`: Upper-left diagonal (Northwest)
  - `2`: Upper-right diagonal (Northeast)
  - `3`: Lower-right diagonal (Southeast)
  - `4`: Lower-left diagonal (Southwest)

### Uppercase Letters
- Uppercase versions of the movement letters (`U`, `D`, `R`, `L`, `1`, `2`, `3`, `4`) indicate the piece can move in the specified direction continuously until it reaches the edge of the board or encounters an obstacle. This is typically used for pieces like the Rook, Bishop, and Queen.

### Wildcard (`*`)
- Represents the King's ability to move one step in any direction. The wildcard pulls all possible one-step moves from the defined moves and applies them to the King's current position.

## Disclaimer
Please note that the numerical results generated by this engine have not been independently verified for accuracy. While the engine has been tested using the accompanying console application, it does not include unit tests.

## Usage
Instructions on how to configure and use the chess engine are included in the JSON configuration file within this repository. Users can modify this file to test different configurations and scenarios without altering the core application.
